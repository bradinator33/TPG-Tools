<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random US Coordinates Generator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    <style>
        body { font-family: sans-serif; padding: 1em; }
        #map {
            width: 100%;
            height: 700px;
            margin-top: 1em;
            border: 1px solid #ccc;
        }
        #stateSelector {
            width: 250px;
            height: 200px;
            vertical-align: top;
        }
        label {
            display: block;
            margin-top: 1em;
            font-weight: bold;
        }
        button {
            margin-top: 1em;
        }
        button:disabled {
            cursor: not-allowed;
            color: #aaa;
        }
        #output {
            margin-top: 1em;
            font-family: monospace;
            font-size: 1.1em;
            background-color: #f4f4f4;
            padding: 0.5em;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow-y: auto;
        }
        #loader {
            display: none;
            margin-top: 1em;
            font-style: italic;
            color: #555;
        }
        .controls-group {
            margin-top: 1em;
        }
    </style>
</head>
<body onload="initMap()">

    <h1>Random US Coordinates Generator</h1>
    <h3>Select a region or individual states. Leave blank to generate a location anywhere in the US.</h3>

    <label for="regionSelector">Region Presets:</label>
    <select id="regionSelector">
        <option value="">-- Select a Region --</option>
        <option value="midwest">Midwest</option>
        <option value="west">West</option>
        <option value="south">South</option>
        <option value="new_england">New England</option>
        <option value="mid_atlantic">Mid-Atlantic</option>
        <option value="territories">US Territories</option>
    </select>

    <div>
        <label for="stateSelector">Select States (Hold Ctrl/Cmd to select multiple):</label>
        <select id="stateSelector" multiple>
        </select>
    </div>
    
    <button id="clearSelectionBtn">Clear Selection</button>
    <button id="downloadBtn" disabled>Download Locations as CSV</button>
    
    <div class="controls-group">
        <button id="generateBtn">Generate Single Location</button>
    </div>

    <div class="controls-group">
        <label for="numToGenerate">Number of Locations:</label>
        <input type="number" id="numToGenerate" value="10" min="1" max="1000" style="width: 60px;">
        <button id="generateMultipleBtn">Generate Multiple Locations</button>
    </div>

    <div id="output">Click a button to generate coordinates.</div>
    <div id="loader">Finding a valid point...</div>

    <div id="map"></div>

    <script>
        let map;
        let pinsLayer = null;
        let boundaryLayer = null;
        const stateGeoJsonCache = new Map();
        let generatedLocations = [];
        let shouldDrawBoundary = true;

        const stateNames = [
            "Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut", "Delaware", "Florida", "Georgia",
            "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland",
            "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey",
            "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina",
            "South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "West Virginia", "Wisconsin", "Wyoming",
            "American Samoa", "Guam", "Northern Mariana Islands", "Puerto Rico", "U.S. Virgin Islands"
        ];

        const stateAreas = {
            "Alabama": 131171, "Alaska": 1477953, "Arizona": 294207, "Arkansas": 134771, "California": 403466,
            "Colorado": 268431, "Connecticut": 12542, "Delaware": 5047, "Florida": 138887, "Georgia": 149165,
            "Hawaii": 16635, "Idaho": 214045, "Illinois": 143793, "Indiana": 92789, "Iowa": 144669,
            "Kansas": 211754, "Kentucky": 102269, "Louisiana": 111898, "Maine": 79883, "Maryland": 25147,
            "Massachusetts": 20202, "Michigan": 146435, "Minnesota": 206232, "Mississippi": 121531, "Missouri": 178040,
            "Montana": 376962, "Nebraska": 198974, "Nevada": 284332, "New Hampshire": 23187, "New Jersey": 19047,
            "New Mexico": 314161, "New York": 122057, "North Carolina": 125920, "North Dakota": 178711, "Ohio": 105829,
            "Oklahoma": 177660, "Oregon": 248608, "Pennsylvania": 115883, "Rhode Island": 2678, "South Carolina": 77857,
            "South Dakota": 196350, "Tennessee": 106798, "Texas": 676587, "Utah": 212818, "Vermont": 23871,
            "Virginia": 102279, "Washington": 172119, "West Virginia": 62259, "Wisconsin": 140268, "Wyoming": 251470,
            "American Samoa": 199, "Guam": 544, "Northern Mariana Islands": 464, "Puerto Rico": 8870, "U.S. Virgin Islands": 346
        };
        
        const regionPresets = {
            midwest: ["Illinois", "Indiana", "Iowa", "Kansas", "Michigan", "Minnesota", "Missouri", "Nebraska", "North Dakota", "Ohio", "South Dakota", "Wisconsin"],
            west: ["Arizona", "California", "Colorado", "Idaho", "Montana", "Nevada", "New Mexico", "Oregon", "Utah", "Washington", "Wyoming"],
            south: ["Alabama", "Arkansas", "Florida", "Georgia", "Kentucky", "Louisiana", "Mississippi", "Missouri", "North Carolina", "Oklahoma", "South Carolina", "Tennessee", "Texas", "Virginia", "West Virginia"],
            new_england: ["Connecticut", "Maine", "Massachusetts", "New Hampshire", "Rhode Island", "Vermont"],
            mid_atlantic: ["Delaware", "Maryland", "New Jersey", "New York", "Pennsylvania", "Virginia", "West Virginia"],
            territories: ["American Samoa", "Guam", "Northern Mariana Islands", "Puerto Rico", "U.S. Virgin Islands"]
        };
        
        const territoryUrls = {
            "American Samoa": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/AmericanSamoa.geojson",
            "Guam": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/Guam.geojson",
            "Northern Mariana Islands": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/NMI.geojson",
            "Puerto Rico": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/PR.geojson",
            "U.S. Virgin Islands": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/USVI.geojson"
        };

        function initMap() {
            map = L.map('map').setView([39.8283, -98.5795], 4);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            boundaryLayer = L.geoJSON(null, { style: { color: "#22c55e", weight: 2, opacity: 0.8, fill: false } }).addTo(map);
            pinsLayer = L.featureGroup().addTo(map);
            
            populateStateSelector();
            document.getElementById('generateBtn').addEventListener('click', handleSingleGeneration);
            document.getElementById('generateMultipleBtn').addEventListener('click', handleMultipleGeneration);
            document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
            document.getElementById('regionSelector').addEventListener('change', handleRegionSelect);
            document.getElementById('clearSelectionBtn').addEventListener('click', clearStateSelection);
        }

        function populateStateSelector() {
            const selector = document.getElementById('stateSelector');
            stateNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selector.appendChild(option);
            });
        }
        
        function handleRegionSelect(event) {
            const selectedRegion = event.target.value;
            const stateSelector = document.getElementById('stateSelector');
            const statesToSelect = regionPresets[selectedRegion] || [];
            for (const option of stateSelector.options) {
                option.selected = statesToSelect.includes(option.value);
            }
        }

        function clearStateSelection() {
            const stateSelector = document.getElementById('stateSelector');
            for (const option of stateSelector.options) {
                option.selected = false;
            }
            document.getElementById('regionSelector').value = "";
        }

        function showLoader(text) {
            const loader = document.getElementById('loader');
            loader.textContent = text;
            loader.style.display = 'block';
            document.getElementById('output').style.display = 'none';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('generateMultipleBtn').disabled = true;
        }

        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('output').style.display = 'block';
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('generateMultipleBtn').disabled = false;
        }

        function updateOutput(html) {
            document.getElementById('output').innerHTML = html;
        }
        
        function addPointToMap(lat, lon, locationData) {
            const location = L.latLng(lat, lon);
            let popupContent = `<b>${lat.toFixed(5)}, ${lon.toFixed(5)}</b><br>${locationData.county || 'N/A'}, ${locationData.state}`;
            L.marker(location).addTo(pinsLayer).bindPopup(popupContent);
        }

        function resetUI() {
            boundaryLayer.clearLayers();
            pinsLayer.clearLayers();
            generatedLocations = [];
            document.getElementById('downloadBtn').disabled = true;
            updateOutput('Click a button to generate coordinates.');
        }

        async function handleSingleGeneration() {
            resetUI();
            shouldDrawBoundary = true;
            const location = await generateSinglePoint();
            if (location) {
                generatedLocations.push(location);
                addPointToMap(location.lat, location.lon, location);
                updateOutput(`${location.lat.toFixed(5)}, ${location.lon.toFixed(5)}<br>${location.county}, ${location.state}`);
                document.getElementById('downloadBtn').disabled = false;
                map.setView([location.lat, location.lon], 6);
            }
        }
        
        async function handleMultipleGeneration() {
            resetUI();
            shouldDrawBoundary = false; 
            const numToGenerate = parseInt(document.getElementById('numToGenerate').value, 10);
            if (isNaN(numToGenerate) || numToGenerate < 1) {
                alert("Please enter a valid number of locations to generate.");
                return;
            }

            for (let i = 1; i <= numToGenerate; i++) {
                showLoader(`Generating ${i} of ${numToGenerate}...`);
                const location = await generateSinglePoint();
                if (location) {
                    generatedLocations.push(location);
                    addPointToMap(location.lat, location.lon, location);
                }
            }
            
            hideLoader();
            const outputHtml = generatedLocations.map(loc => `<li>${loc.lat.toFixed(5)}, ${loc.lon.toFixed(5)} (${loc.county}, ${loc.state})</li>`).join('');
            updateOutput(`<ul>${outputHtml}</ul>`);
            document.getElementById('downloadBtn').disabled = false;
            if (pinsLayer.getLayers().length > 0) {
                map.fitBounds(pinsLayer.getBounds().pad(0.1));
            }
        }

        async function generateSinglePoint() {
            const selectedStates = Array.from(document.getElementById('stateSelector').selectedOptions).map(opt => opt.value);
            
            let point = null;
            if (selectedStates.length > 0) {
                point = await generateLocationInStates(selectedStates);
            } else {
                point = await generateLocationInUSA();
            }

            hideLoader();
            return point;
        }

        async function generateLocationInStates(states) {
            try {
                const geojsonPromises = states.map(fetchStateGeoJSON);
                const geojsonArray = await Promise.all(geojsonPromises);
                if (shouldDrawBoundary && !boundaryLayer.getLayers().length) {
                    boundaryLayer.addData(geojsonArray);
                }
                
                const weightedFeatures = geojsonArray.map(feature => {
                    const area = turf.area(feature);
                    return { feature, area };
                });
                const totalArea = weightedFeatures.reduce((sum, item) => sum + item.area, 0);

                let random = Math.random() * totalArea;
                let selectedFeature = weightedFeatures[weightedFeatures.length - 1].feature;
                for (const item of weightedFeatures) {
                    random -= item.area;
                    if (random <= 0) {
                        selectedFeature = item.feature;
                        break;
                    }
                }
                
                const validPoint = await generatePointInSingleBoundary(selectedFeature.properties.name, selectedFeature);
                
                const locationDetails = await checkIfValidUSLocation(validPoint.lat, validPoint.lon);
                validPoint.county = locationDetails.county || 'N/A';
                return validPoint;

            } catch (error) {
                console.error("Error fetching or processing state boundaries:", error);
                updateOutput(`<span style="color: red;">Error: ${error.message}</span>`);
                return null;
            }
        }

        async function generateLocationInUSA() {
            const weightedStates = [];
            let totalWeight = 0;
            
            for (const name of stateNames) {
                const area = stateAreas[name];
                if (!area) continue;
                
                let weight = area;
                if (name === "Alaska") {
                    weight /= 5.0;
                }
                weightedStates.push({ name: name, weight: weight });
                totalWeight += weight;
            }

            let random = Math.random() * totalWeight;
            let selectedStateName = weightedStates[weightedStates.length - 1].name;
            for (const state of weightedStates) {
                random -= state.weight;
                if (random <= 0) {
                    selectedStateName = state.name;
                    break;
                }
            }
            
            const point = await generatePointInSingleBoundary(selectedStateName);

            const locationDetails = await checkIfValidUSLocation(point.lat, point.lon);
            point.county = locationDetails.county || 'N/A';
            point.state = locationDetails.state || selectedStateName;
            return point;
        }
        
        async function generatePointInSingleBoundary(stateName, stateGeoJSON = null) {
            try {
                if (!stateGeoJSON) {
                    stateGeoJSON = await fetchStateGeoJSON(stateName);
                }
                
                showLoader(`Finding a valid point in ${stateName}...`);
                
                if (shouldDrawBoundary && boundaryLayer && !boundaryLayer.getLayers().length) {
                    boundaryLayer.addData(stateGeoJSON);
                }

                while (true) {
                    const singleBbox = turf.bbox(stateGeoJSON);
                    const regionForBbox = { minLon: singleBbox[0], minLat: singleBbox[1], maxLon: singleBbox[2], maxLat: singleBbox[3] };
                    const coord = getRandomCoordinateInRegion(regionForBbox);
                    const randomPoint = turf.point([coord.lon, coord.lat]);

                    if (turf.booleanPointInPolygon(randomPoint, stateGeoJSON)) {
                        return { lat: coord.lat, lon: coord.lon, state: stateGeoJSON.properties.name };
                    }
                }
            } catch (error) {
                console.error(`Error generating point in ${stateName}:`, error);
                updateOutput(`<span style="color: red;">Error: Could not fetch data for ${stateName}.</span>`);
                return null;
            }
        }

        async function fetchStateGeoJSON(stateName) {
            if (stateGeoJsonCache.has(stateName)) return stateGeoJsonCache.get(stateName);
            
            let url = territoryUrls[stateName] || `https://raw.githubusercontent.com/glynnbird/usstatesgeojson/refs/heads/master/${stateName.toLowerCase()}.geojson`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Could not fetch boundary for ${stateName}`);
            const geojson = await response.json();
            
            let feature;
            if (geojson.type === 'Feature') feature = geojson;
            else if (geojson.type === 'FeatureCollection') feature = geojson.features[0];
            else feature = turf.feature(geojson);  

            feature.properties = feature.properties || {};
            feature.properties.name = stateName;
            stateGeoJsonCache.set(stateName, feature);
            return feature;
        }

        function getRandomCoordinateInRegion(region) {
            const lon = Math.random() * (region.maxLon - region.minLon) + region.minLon;
            const minLatRad = region.minLat * Math.PI / 180;
            const maxLatRad = region.maxLat * Math.PI / 180;
            const u = Math.random() * (Math.sin(maxLatRad) - Math.sin(minLatRad)) + Math.sin(minLatRad);
            const latRad = Math.asin(u);
            const lat = latRad * 180 / Math.PI;
            return { lat, lon };
        }

        async function checkIfValidUSLocation(lat, lon) {
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en`;
                const response = await fetch(url, { headers: { 'User-Agent': 'RandomCoordGenerator/1.0' } });
                if (!response.ok) return { valid: false };
                const data = await response.json();
                const countryCode = data.address?.country_code;
                if (data && data.address && ["us", "as", "gu", "mp", "pr", "vi"].includes(countryCode)) {
                    return {
                        valid: true,
                        state: data.address.state || "Unknown",
                        county: data.address.county || data.address.city || "N/A"
                    };
                }
            } catch (error) {
                console.error("Nominatim API error:", error);
            }
            return { valid: false };
        }

        function downloadCSV() {
            if (generatedLocations.length === 0) return;

            const headers = "Latitude,Longitude,County,State";
            const csvContent = [
                headers,
                ...generatedLocations.map(loc => `${loc.lat},${loc.lon},"${loc.county || ''}","${loc.state || ''}"`)
            ].join("\n");

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "locations.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

    </script>
</body>
</html>
