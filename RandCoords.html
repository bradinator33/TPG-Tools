<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random US Coordinates Generator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    <style>
        body { font-family: sans-serif; padding: 1em; }
        #map {
            width: 100%;
            height: 700px;
            margin-top: 1em;
            border: 1px solid #ccc;
        }
        #stateSelector {
            width: 250px;
            height: 200px;
            vertical-align: top;
        }
        label {
            display: block;
            margin-top: 1em;
            font-weight: bold;
        }
        button {
            margin-top: 1em;
        }
        button:disabled {
            cursor: not-allowed;
            color: #aaa;
        }
        #output {
            margin-top: 1em;
            font-family: monospace;
            font-size: 1.1em;
            background-color: #f4f4f4;
            padding: 0.5em;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow-y: auto;
        }
        #loader {
            display: none;
            margin-top: 1em;
            font-style: italic;
            color: #555;
        }
        .controls-group {
            margin-top: 1em;
        }
    </style>
</head>
<body onload="initMap()">

    <h1>Random US Coordinates Generator</h1>
    <h3>Select a region or individual states. Leave blank to generate a location anywhere in the US.</h3>

    <label for="regionSelector">Region Presets:</label>
    <select id="regionSelector">
        <option value="">-- Select a Region --</option>
        <option value="midwest">Midwest</option>
        <option value="west">West</option>
        <option value="south">South</option>
        <option value="new_england">New England</option>
        <option value="mid_atlantic">Mid-Atlantic</option>
        <option value="territories">US Territories</option>
    </select>

    <div>
        <label for="stateSelector">Select States (Hold Ctrl/Cmd to select multiple):</label>
        <select id="stateSelector" multiple>
        </select>
    </div>
    
    <button id="clearSelectionBtn">Clear Selection</button>
    <button id="downloadBtn" disabled>Download Locations as CSV</button>
    
    <div class="controls-group">
        <button id="generateBtn">Generate Single Location</button>
    </div>

    <div class="controls-group">
        <label for="numToGenerate">Number of Locations:</label>
        <input type="number" id="numToGenerate" value="10" min="1" max="1000" style="width: 60px;">
        <button id="generateMultipleBtn">Generate Multiple Locations</button>
    </div>

    <div id="output">Click a button to generate coordinates.</div>
    <div id="loader">Finding a valid point...</div>

    <div id="map"></div>

    <script>
        let map;
        let pinsLayer = null;
        let boundaryLayer = null;
        const stateGeoJsonCache = new Map();
        let generatedLocations = [];

        const stateNames = [
            "Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut", "Delaware", "Florida", "Georgia",
            "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland",
            "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey",
            "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina",
            "South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "West Virginia", "Wisconsin", "Wyoming",
            "American Samoa", "Guam", "Northern Mariana Islands", "Puerto Rico", "U.S. Virgin Islands"
        ];
        
        const regionPresets = {
            midwest: ["Illinois", "Indiana", "Iowa", "Kansas", "Michigan", "Minnesota", "Missouri", "Nebraska", "North Dakota", "Ohio", "South Dakota", "Wisconsin"],
            west: ["Arizona", "California", "Colorado", "Idaho", "Montana", "Nevada", "New Mexico", "Oregon", "Utah", "Washington", "Wyoming"],
            south: ["Alabama", "Arkansas", "Florida", "Georgia", "Kentucky", "Louisiana", "Mississippi", "Missouri", "North Carolina", "Oklahoma", "South Carolina", "Tennessee", "Texas", "Virginia", "West Virginia"],
            new_england: ["Connecticut", "Maine", "Massachusetts", "New Hampshire", "Rhode Island", "Vermont"],
            mid_atlantic: ["Delaware", "Maryland", "New Jersey", "New York", "Pennsylvania", "Virginia", "West Virginia"],
            territories: ["American Samoa", "Guam", "Northern Mariana Islands", "Puerto Rico", "U.S. Virgin Islands"]
        };
        
        const regionBoundingBoxes = {
            midwest: { minLat: 35.8, maxLat: 49.8, minLon: -104.5, maxLon: -80 },
            west: { minLat: 31.2, maxLat: 49.3, minLon: -125.7, maxLon: -102.5 },
            south: { minLat: 24.3, maxLat: 41.2, minLon: -100.3, maxLon: -74.6 },
            new_england: { minLat: 40.8, maxLat: 47.5, minLon: -73.8, maxLon: -66.5 },
            mid_atlantic: { minLat: 36.5, maxLat: 45.1, minLon: -83.74, maxLon: -71.66 }
        };

        const territoryUrls = {
            "American Samoa": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/AmericanSamoa.geojson",
            "Guam": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/Guam.geojson",
            "Northern Mariana Islands": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/NMI.geojson",
            "Puerto Rico": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/PR.geojson",
            "U.S. Virgin Islands": "https://raw.githubusercontent.com/bradinator33/TPG-Tools/refs/heads/main/USVI.geojson"
        };

        function initMap() {
            map = L.map('map').setView([39.8283, -98.5795], 4);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            boundaryLayer = L.geoJSON(null, { style: { color: "#22c55e", weight: 2, opacity: 0.8, fill: false } }).addTo(map);
            pinsLayer = L.featureGroup().addTo(map);
            
            populateStateSelector();
            document.getElementById('generateBtn').addEventListener('click', handleSingleGeneration);
            document.getElementById('generateMultipleBtn').addEventListener('click', handleMultipleGeneration);
            document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
            document.getElementById('regionSelector').addEventListener('change', handleRegionSelect);
            document.getElementById('clearSelectionBtn').addEventListener('click', clearStateSelection);
        }

        function populateStateSelector() {
            const selector = document.getElementById('stateSelector');
            stateNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selector.appendChild(option);
            });
        }
        
        function handleRegionSelect(event) {
            const selectedRegion = event.target.value;
            const stateSelector = document.getElementById('stateSelector');
            const statesToSelect = regionPresets[selectedRegion] || [];
            for (const option of stateSelector.options) {
                option.selected = statesToSelect.includes(option.value);
            }
        }

        function clearStateSelection() {
            const stateSelector = document.getElementById('stateSelector');
            for (const option of stateSelector.options) {
                option.selected = false;
            }
            document.getElementById('regionSelector').value = "";
        }

        function showLoader(text) {
            const loader = document.getElementById('loader');
            loader.textContent = text;
            loader.style.display = 'block';
            document.getElementById('output').style.display = 'none';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('generateMultipleBtn').disabled = true;
        }

        function hideLoader() {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('output').style.display = 'block';
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('generateMultipleBtn').disabled = false;
        }

        function updateOutput(html) {
            document.getElementById('output').innerHTML = html;
        }
        
        function addPointToMap(lat, lon, locationData) {
            const location = L.latLng(lat, lon);
            let popupContent = `<b>${lat.toFixed(5)}, ${lon.toFixed(5)}</b><br>${locationData.county || 'N/A'}, ${locationData.state}`;
            L.marker(location).addTo(pinsLayer).bindPopup(popupContent);
        }

        function resetUI() {
            boundaryLayer.clearLayers();
            pinsLayer.clearLayers();
            generatedLocations = [];
            document.getElementById('downloadBtn').disabled = true;
            updateOutput('Click a button to generate coordinates.');
        }

        async function handleSingleGeneration() {
            resetUI();
            const location = await generateSinglePoint();
            if (location) {
                generatedLocations.push(location);
                addPointToMap(location.lat, location.lon, location);
                updateOutput(`${location.lat.toFixed(5)}, ${location.lon.toFixed(5)}<br>${location.county}, ${location.state}`);
                document.getElementById('downloadBtn').disabled = false;
                map.setView([location.lat, location.lon], 6);
            }
        }
        
        async function handleMultipleGeneration() {
            resetUI();
            const numToGenerate = parseInt(document.getElementById('numToGenerate').value, 10);
            if (isNaN(numToGenerate) || numToGenerate < 1) {
                alert("Please enter a valid number of locations to generate.");
                return;
            }

            for (let i = 1; i <= numToGenerate; i++) {
                showLoader(`Generating ${i} of ${numToGenerate}...`);
                const location = await generateSinglePoint();
                if (location) {
                    generatedLocations.push(location);
                    addPointToMap(location.lat, location.lon, location);
                } else {
                    updateOutput(`Failed to generate point ${i}. Please try again.`);
                    hideLoader();
                    return;
                }
            }
            
            hideLoader();
            const outputHtml = generatedLocations.map(loc => `<li>${loc.lat.toFixed(5)}, ${loc.lon.toFixed(5)} (${loc.county}, ${loc.state})</li>`).join('');
            updateOutput(`<ul>${outputHtml}</ul>`);
            document.getElementById('downloadBtn').disabled = false;
            if (pinsLayer.getLayers().length > 0) {
                map.fitBounds(pinsLayer.getBounds().pad(0.1));
            }
        }

        async function generateSinglePoint() {
            const selectedStates = Array.from(document.getElementById('stateSelector').selectedOptions).map(opt => opt.value);
            const selectedRegion = document.getElementById('regionSelector').value;
            showLoader('Finding a valid point...');

            let point = null;
            if (selectedStates.length > 0) {
                point = await generateLocationInStates(selectedStates, selectedRegion);
            } else {
                point = await generateLocationInUSA();
            }

            hideLoader();
            return point;
        }

        async function generateLocationInStates(states, regionName) {
            try {
                const geojsonPromises = states.map(fetchStateGeoJSON);
                const geojsonArray = await Promise.all(geojsonPromises);
                if (!boundaryLayer.getLayers().length) {
                    boundaryLayer.addData(geojsonArray);
                }
                
                let validPoint = null;
                let attempts = 0;

                const regionBbox = regionBoundingBoxes[regionName];

                if (regionBbox) {
                    while (!validPoint && attempts < 1000) {
                        const coord = getRandomCoordinateInRegion(regionBbox);
                        const randomPoint = turf.point([coord.lon, coord.lat]);
                        
                        for (const stateGeoJSON of geojsonArray) {
                            if (turf.booleanPointInPolygon(randomPoint, stateGeoJSON)) {
                                validPoint = { lat: coord.lat, lon: coord.lon, state: stateGeoJSON.properties.name };
                                break;
                            }
                        }
                        attempts++;
                    }
                } else {
                    const weightedFeatures = geojsonArray.map(feature => {
                        const bbox = turf.bbox(feature);
                        const area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1]);
                        return { feature, area };
                    });
                    const totalArea = weightedFeatures.reduce((sum, item) => sum + item.area, 0);

                    while (!validPoint && attempts < 500) {
                        let random = Math.random() * totalArea;
                        let selectedFeature = weightedFeatures[weightedFeatures.length - 1].feature;
                        for (const item of weightedFeatures) {
                            random -= item.area;
                            if (random <= 0) {
                                selectedFeature = item.feature;
                                break;
                            }
                            // Why hello! I think the coords you are looking for might be 36.55798, -90.07773
                        }
                        
                        const singleBbox = turf.bbox(selectedFeature);
                        const regionForBbox = { minLon: singleBbox[0], minLat: singleBbox[1], maxLon: singleBbox[2], maxLat: singleBbox[3] };
                        const coord = getRandomCoordinateInRegion(regionForBbox);
                        const randomPoint = turf.point([coord.lon, coord.lat]);
                        
                        if (turf.booleanPointInPolygon(randomPoint, selectedFeature)) {
                            validPoint = { lat: coord.lat, lon: coord.lon, state: selectedFeature.properties.name };
                        }
                        attempts++;
                    }
                }

                if (validPoint) {
                    const locationDetails = await checkIfValidUSLocation(validPoint.lat, validPoint.lon);
                    validPoint.county = locationDetails.county || 'N/A';
                    return validPoint;
                }
                return null;
            } catch (error) {
                console.error("Error fetching or processing state boundaries:", error);
                updateOutput(`<span style="color: red;">Error: ${error.message}</span>`);
                return null;
            }
        }

        async function generateLocationInUSA() {
            let attempts = 0;
            while (attempts < 100) {
                const region = getRandomUSRegion();
                const coord = getRandomCoordinateInRegion(region);
                const locationData = await checkIfValidUSLocation(coord.lat, coord.lon);
                if (locationData.valid && locationData.county !== "Unknown") {
                    return { ...coord, ...locationData };
                }
                attempts++;
            }
            updateOutput('Could not find a valid US location after many attempts. Please try again.');
            return null;
        }

        async function fetchStateGeoJSON(stateName) {
            if (stateGeoJsonCache.has(stateName)) return stateGeoJsonCache.get(stateName);
            
            let url = territoryUrls[stateName] || `https://raw.githubusercontent.com/glynnbird/usstatesgeojson/refs/heads/master/${stateName.toLowerCase()}.geojson`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Could not fetch boundary for ${stateName}`);
            const geojson = await response.json();
            
            let feature;
            if (geojson.type === 'Feature') feature = geojson;
            else if (geojson.type === 'FeatureCollection') feature = geojson.features[0];
            else feature = turf.feature(geojson); 

            feature.properties = feature.properties || {};
            feature.properties.name = stateName;
            stateGeoJsonCache.set(stateName, feature);
            return feature;
        }

        function getRandomUSRegion() {
            const regions = [
                { name: "Contiguous US", minLat: 24.8, maxLat: 49.0, minLon: -124.72, maxLon: -66.8 },
                { name: "Hawaii", minLat: 18.8, maxLat: 22.4, minLon: -160.4, maxLon: -154.1 },
                { name: "Alaska", minLat: 54.0, maxLat: 71.5, minLon: -179.0, maxLon: -129.5 }
            ];
            const rand = Math.random();
            if (rand < 0.98) return regions[0];
            if (rand < 0.99) return regions[2];
            return regions[1];
        }

        function getRandomCoordinateInRegion(region) {
            const lon = Math.random() * (region.maxLon - region.minLon) + region.minLon;

            const minLatRad = region.minLat * Math.PI / 180;
            const maxLatRad = region.maxLat * Math.PI / 180;

            const u = Math.random() * (Math.sin(maxLatRad) - Math.sin(minLatRad)) + Math.sin(minLatRad);

            const latRad = Math.asin(u);
            const lat = latRad * 180 / Math.PI;

            return { lat, lon };
        }

        async function checkIfValidUSLocation(lat, lon) {
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en`;
                const response = await fetch(url, { headers: { 'User-Agent': 'RandomCoordGenerator/1.0' } });
                if (!response.ok) return { valid: false };
                const data = await response.json();
                const countryCode = data.address?.country_code;
                if (data && data.address && ["us", "as", "gu", "mp", "pr", "vi"].includes(countryCode)) {
                    return {
                        valid: true,
                        state: data.address.state || "Unknown",
                        county: data.address.county || data.address.city || "N/A"
                    };
                }
            } catch (error) {
                console.error("Nominatim API error:", error);
            }
            return { valid: false };
        }

        function downloadCSV() {
            if (generatedLocations.length === 0) return;

            const headers = "Latitude,Longitude,County,State";
            const csvContent = [
                headers,
                ...generatedLocations.map(loc => `${loc.lat},${loc.lon},"${loc.county || ''}","${loc.state || ''}"`)
            ].join("\n");

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "locations.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

    </script>
</body>
</html>

